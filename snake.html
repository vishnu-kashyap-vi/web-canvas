<!DOCTYPE html>
<html>
<head>
  <title>Snake & Ladder | V Ã— S</title>
  <meta charset="UTF-8">

  <!-- PAGE ICON (V Ã— S) -->
  <link rel="icon" type="image/jpg" href="favicon.jpg">

  <!-- Tailwind for styling -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    /* ===== BOARD (uses your image) ===== */
    .board {
      display: grid;
      grid-template-columns: repeat(10, 50px);
      grid-template-rows: repeat(10, 50px);
      width: 500px;
      height: 500px;
      border: 4px solid #2563eb;
      background-image: url("snake-board.png");
      background-size: cover;
      background-position: center;
    }

    .cell {
      width: 50px;
      height: 50px;
      font-size: 0;
      color: transparent;
      border: 1px solid transparent;
      position: relative;
    }

    /* ===== PLAYER TOKENS (centered) ===== */
    .dot {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .dot.p1 { background: #ef4444; box-shadow: 0 0 10px rgba(239,68,68,0.9); }
    .dot.p2 { background: #60a5fa; box-shadow: 0 0 10px rgba(96,165,250,0.9); }
    .dot.p3 { background: #22c55e; box-shadow: 0 0 10px rgba(34,197,94,0.9); }
    .dot.p4 { background: #eab308; box-shadow: 0 0 10px rgba(234,179,8,0.9); }

    /* climb / slide animation */
    .dot.climb {
      animation: climbAnim 0.3s ease-out forwards;
    }
    .dot.slide {
      animation: slideAnim 0.3s ease-out forwards;
    }

    @keyframes climbAnim {
      0% { opacity: 1; }
      100% { opacity: 1; }
    }

    @keyframes slideAnim {
      0% { opacity: 1; }
      100% { opacity: 1; }
    }

    /* ===== DICE (image + animation) ===== */
    #diceFace {
      width: 50px;
      height: 50px;
      border-radius: 0.9rem;
      border: 2px solid #eab308;
      background-size: cover;
      background-position: center;
      box-shadow:
        0 0 15px rgba(234,179,8,0.6),
        0 6px 0 rgba(15, 23, 42, 1);
    }

    #diceWrapper.animate {
      animation: diceShake 0.4s linear infinite;
    }

    @keyframes diceShake {
      0% { transform: translate(0, 0) rotate(0deg); }
      25% { transform: translate(-2px, -2px) rotate(-6deg); }
      50% { transform: translate(3px, 1px) rotate(5deg); }
      75% { transform: translate(-1px, 2px) rotate(-4deg); }
      100% { transform: translate(0, 0) rotate(0deg); }
    }

    /* ===== WINNER OVERLAY ===== */
    #winnerOverlay {
      background-image:
        radial-gradient(circle at 10% 20%, rgba(249,115,22,0.5), transparent 60%),
        radial-gradient(circle at 80% 30%, rgba(56,189,248,0.5), transparent 60%),
        radial-gradient(circle at 50% 80%, rgba(190,242,100,0.5), transparent 60%),
        rgba(0,0,0,0.85);
    }

    #winnerText {
      animation: winnerPulse 1.2s ease-in-out infinite;
    }

    @keyframes winnerPulse {
      0% { transform: scale(0.96); text-shadow: 0 0 8px rgba(250,250,210,0.7); }
      100% { transform: scale(1.04); text-shadow: 0 0 18px rgba(250,250,210,1); }
    }
    
    /* ===== MULTIPLE PAWNS ON ONE SQUARE ===== */
    .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    .dot-container {
      position: absolute;
      width: 50px;
      height: 50px;
      top: 0;
      left: 0;
    }
  </style>
</head>

<body class="min-h-screen bg-gradient-to-b from-black via-slate-900 to-black text-white">
  <div class="max-w-6xl mx-auto px-4 py-8 flex flex-col lg:flex-row gap-8">

    <!-- LEFT: BOARD -->
    <div class="flex flex-col items-center gap-3">
      <a href="games.html" class="self-start text-sm text-slate-300 hover:text-purple-300">
        &larr; Back to Games
      </a>

      <h1 class="text-3xl font-extrabold text-purple-400 text-center drop-shadow-md">
        Snake &amp; Ladder
      </h1>

      <p class="text-xs text-slate-300 text-center max-w-xs">
        2â€“4 players on one device. Red / Blue / Green / Yellow pawns. Animated dice & movement.
      </p>

      <div id="board" class="board"></div>
    </div>

    <!-- RIGHT: CONTROLS -->
    <div class="flex-1 flex flex-col gap-4">

      <!-- SETUP -->
      <div class="bg-white/5 border border-white/10 rounded-2xl p-4 backdrop-blur flex flex-col gap-3">
        <p class="font-semibold text-slate-100 text-sm">Setup</p>

        <div class="flex items-center gap-3 text-xs text-slate-200">
          <span>Number of players:</span>
          <select id="playerCount" class="bg-black/40 border border-slate-600 rounded px-2 py-1">
            <option value="2">2 players</option>
            <option value="3">3 players</option>
            <option value="4">4 players</option>
          </select>
        </div>

        
          <div id="p1Row">
            <label>Player 1 (Red):
              <input id="p1Name"
                     class="mt-1 w-full bg-black/40 border border-red-400/60 rounded px-2 py-1"
                     placeholder="Player 1">
            </label>
          </div>
          <div id="p2Row">
            <label>Player 2 (Blue):
              <input id="p2Name"
                     class="mt-1 w-full bg-black/40 border border-blue-400/60 rounded px-2 py-1"
                     placeholder="Player 2">
            </label>
          </div>
          <div id="p3Row">
            <label>Player 3 (Green):
              <input id="p3Name"
                     class="mt-1 w-full bg-black/40 border border-emerald-400/60 rounded px-2 py-1"
                     placeholder="Player 3">
            </label>
          </div>
          <div id="p4Row">
            <label>Player 4 (Yellow):
              <input id="p4Name"
                     class="mt-1 w-full bg-black/40 border border-yellow-400/60 rounded px-2 py-1"
                     placeholder="Player 4">
            </label>
          </div>
        </div>

        <button id="startBtn"
                class="mt-2 px-4 py-2 rounded-full bg-cyan-500 hover:bg-cyan-400 text-xs font-semibold
                       shadow-[0_0_15px_rgba(34,211,238,0.8)] w-fit">
          âœ… Start game
        </button>

        <p id="setupInfo" class="text-[11px] text-slate-300 min-h-[1.3rem]"></p>
      </div>

      <!-- GAME INFO -->
      <div class="bg-white/5 border border-white/10 rounded-2xl p-5 backdrop-blur flex flex-col gap-3">
        <p id="turnText" class="font-semibold text-purple-300 text-sm">
          Click "Start game" to begin
        </p>

        <div id="playerList" class="grid grid-cols-2 gap-3 text-xs"></div>

        <div class="flex items-center gap-3">
          <span>Dice:</span>
          <div id="diceWrapper" class="flex items-center gap-2">
            <div id="diceFace"></div>
            <span id="diceValue" class="text-lg font-mono text-amber-300">-</span>
          </div>
        </div>

        <div class="flex gap-3 items-center mt-2">
          <button id="rollBtn"
                  class="px-5 py-2 rounded-full bg-purple-500 hover:bg-purple-400 text-white font-semibold
                         shadow-[0_0_20px_rgba(168,85,247,0.9)] transition disabled:opacity-40 disabled:cursor-not-allowed"
                  disabled>
            ðŸŽ² Roll Dice
          </button>
          <button id="resetBtn"
                  class="text-xs text-slate-300 hover:text-slate-100 underline">
            Reset positions
          </button>
        </div>

        <p id="message" class="text-xs text-slate-200 min-h-[1.5rem]"></p>
      </div>
    </div>
  </div>

  <!-- WINNER FULL-SCREEN CELEBRATION -->
  <div id="winnerOverlay"
       class="hidden fixed inset-0 z-50 flex items-center justify-center">
    <div class="text-center px-4">
      <p id="winnerText"
         class="text-4xl md:text-5xl font-extrabold text-yellow-300 drop-shadow-lg mb-4">
      </p>
      <p class="text-sm md:text-lg text-slate-100">
        Click anywhere to play again.
      </p>
    </div>
  </div>

  <!-- RESET CONFIRMATION OVERLAY -->
  <div id="resetOverlay" class="hidden fixed inset-0 z-50 flex items-center justify-center">
    <div class="bg-black/80 rounded-lg p-6 text-center max-w-sm mx-4">
      <p class="text-lg font-semibold text-white mb-4">Restart game?</p>
      <p class="text-sm text-slate-300 mb-6">This will reset all player positions. Are you sure?</p>
      <div class="flex gap-3 justify-center">
        <button id="confirmReset" class="px-4 py-2 rounded bg-red-600 hover:bg-red-500 text-white">Yes, restart</button>
        <button id="cancelReset" class="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600 text-white">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    /* ===== 1. BOARD + SNAKE / LADDER DATA ===== */

    const boardElement = document.getElementById("board");
    const cells = {};

    const ladders = {
      4: 25,
      21: 39,
      26: 67,
      43: 76,
      59: 80,
      71: 89
    };

    const snakes = {
      98: 55,
      92: 75,
      82: 59,
      73: 51,
      56: 19,
      47: 13,
      30: 7
    };

    function buildBoard() {
      boardElement.innerHTML = "";
      for (let n = 1; n <= 100; n++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.num = n;

        const rowFromBottom = Math.floor((n - 1) / 10); // 0..9
        const colInRow = (n - 1) % 10;
        const isReverse = rowFromBottom % 2 === 1;

        const col = isReverse ? 9 - colInRow : colInRow;
        const gridRow = 10 - rowFromBottom;
        const gridCol = col + 1;

        cell.style.gridRow = gridRow;
        cell.style.gridColumn = gridCol;

        boardElement.appendChild(cell);
        cells[n] = cell;
      }
    }

    buildBoard();

    /* ===== 2. GAME STATE ===== */
    let players = [];
    let currentPlayerIndex = 0;
    let gameOver = false;
    let isAnimating = false;
    let activeAnimPlayer = null;
    let activeAnimType = null;

    /* ===== 3. DOM ELEMENTS ===== */

    const playerCountSel = document.getElementById("playerCount");
    const p1NameInput    = document.getElementById("p1Name");
    const p2NameInput    = document.getElementById("p2Name");
    const p3NameInput    = document.getElementById("p3Name");
    const p4NameInput    = document.getElementById("p4Name");

    const p1Row          = document.getElementById("p1Row");
    const p2Row          = document.getElementById("p2Row");
    const p3Row          = document.getElementById("p3Row");
    const p4Row          = document.getElementById("p4Row");

    const startBtn       = document.getElementById("startBtn");
    const setupInfoEl    = document.getElementById("setupInfo");

    const turnTextEl   = document.getElementById("turnText");
    const diceWrapper  = document.getElementById("diceWrapper");
    const diceFace     = document.getElementById("diceFace");
    const diceValueEl  = document.getElementById("diceValue");
    const playerListEl = document.getElementById("playerList");
    const rollBtn      = document.getElementById("rollBtn");
    const resetBtn     = document.getElementById("resetBtn");
    const messageEl    = document.getElementById("message");

    const winnerOverlay = document.getElementById("winnerOverlay");
    const winnerText    = document.getElementById("winnerText");

    /* ===== helper: dice image ===== */
    function setDiceFace(v) {
      diceFace.style.backgroundImage = `url("dice-${v}.png")`;
      diceValueEl.textContent = v;
    }

    setDiceFace(1);

    /* ===== 4. NAME FIELDS SHOW/HIDE ===== */

    function updateNameRows() {
      const count = Number(playerCountSel.value);
      p1Row.classList.remove("hidden");
      p2Row.classList.toggle("hidden", count < 2);
      p3Row.classList.toggle("hidden", count < 3);
      p4Row.classList.toggle("hidden", count < 4);
    }

    playerCountSel.addEventListener("change", updateNameRows);
    updateNameRows();

    /* ===== 5. PLAYER LIST ===== */

    function renderPlayerList() {
      playerListEl.innerHTML = "";
      players.forEach(p => {
        const colorClass =
          p.color === "p1" ? "bg-red-400" :
          p.color === "p2" ? "bg-blue-400" :
          p.color === "p3" ? "bg-emerald-400" : "bg-yellow-300";

        const div = document.createElement("div");
        div.className = "bg-black/40 border border-white/10 rounded-lg p-2";

        div.innerHTML = `
          <p class="font-semibold text-xs">
            <span class="inline-block w-2 h-2 rounded-full mr-1 ${colorClass}"></span>
            ${p.name}
          </p>
        `;
        playerListEl.appendChild(div);
      });
    }

    /* ===== 6. DRAW TOKENS ===== */

    function updateBoardTokens() {
      document.querySelectorAll(".cell").forEach(c => {
        c.querySelectorAll(".dot").forEach(d => d.remove());
      });

      players.forEach(p => {
        const cell = cells[p.pos];
        if (!cell) return;
        const dot = document.createElement("div");
        dot.className = "dot " + p.color;

        if (activeAnimPlayer === p && activeAnimType === "ladder") {
          dot.classList.add("climb");
        } else if (activeAnimPlayer === p && activeAnimType === "snake") {
          dot.classList.add("slide");
        }

        cell.appendChild(dot);
      });

      renderPlayerList();
    }

    /* ===== 7. START GAME ===== */
    /* Helper: Get position offsets for multiple pawns */
    function getPawnPositions(count) {
      if (count === 1) return [{ x: 0, y: 0 }];
      if (count === 2) return [{ x: -7, y: 0 }, { x: 7, y: 0 }];
      if (count === 3) return [{ x: 0, y: -8 }, { x: -8, y: 8 }, { x: 8, y: 8 }]; // triangle
      if (count >= 4) return [{ x: -7, y: -7 }, { x: 7, y: -7 }, { x: -7, y: 7 }, { x: 7, y: 7 }]; // square
    }

    function updateBoardTokens() {
      // Clear old dots
      document.querySelectorAll(".dot").forEach(d => d.remove());

      // Group players by position
      const positionMap = {};
      players.forEach(p => {
        if (!positionMap[p.pos]) positionMap[p.pos] = [];
        positionMap[p.pos].push(p);
      });

      // Render pawns with proper positioning
      Object.keys(positionMap).forEach(pos => {
        const pawnsOnCell = positionMap[pos];
        const cell = cells[pos];
        if (!cell) return;

        const offsets = getPawnPositions(pawnsOnCell.length);

        pawnsOnCell.forEach((p, idx) => {
          const dot = document.createElement("div");
          dot.className = "dot " + p.color;

          const offset = offsets[idx] || { x: 0, y: 0 };
          dot.style.transform = `translate(calc(-50% + ${offset.x}px), calc(-50% + ${offset.y}px))`;

          if (activeAnimPlayer === p && activeAnimType === "ladder") {
            dot.classList.add("climb");
          } else if (activeAnimPlayer === p && activeAnimType === "snake") {
            dot.classList.add("slide");
          }

          cell.appendChild(dot);
        });
      });

      renderPlayerList();
    }

    startBtn.onclick = function () {
      const count = Number(playerCountSel.value);
      const rawNames = [
        p1NameInput.value.trim(),
        p2NameInput.value.trim(),
        p3NameInput.value.trim(),
        p4NameInput.value.trim()
      ];
      const needed = rawNames.slice(0, count);
      if (needed.some(n => !n)) {
        setupInfoEl.textContent = "Giving name is mandatory.";
        setupInfoEl.classList.remove("text-slate-300");
        setupInfoEl.classList.add("text-red-400");
        return;
      }

      setupInfoEl.classList.remove("text-red-400");
      setupInfoEl.classList.add("text-slate-300");

      const colors = ["p1", "p2", "p3", "p4"];
      players = [];
      for (let i = 0; i < count; i++) {
        players.push({ name: needed[i], pos: 1, color: colors[i] });
      }

      currentPlayerIndex = 0;
      gameOver = false;
      isAnimating = false;
      activeAnimPlayer = null;
      activeAnimType = null;
      setDiceFace(1);
      messageEl.textContent = "";
      rollBtn.disabled = false;
      setupInfoEl.textContent = "Game started!";
      winnerOverlay.classList.add("hidden");

      // lock player count once the game has started
      playerCountSel.disabled = true;

      updateBoardTokens();
      updateTurnText();
    };

    function updateTurnText() {
      if (!players.length) {
        turnTextEl.textContent = 'Click "Start game" to begin';
        return;
      }
      turnTextEl.textContent = `${players[currentPlayerIndex].name}'s turn`;
    }

    /* ===== 8. DICE ANIMATION ===== */

    function animateDice(finalValue, callback) {
      diceWrapper.classList.add("animate");
      let count = 0;
      const interval = setInterval(() => {
        const v = Math.floor(Math.random() * 6) + 1;
        setDiceFace(v);
        count++;
        if (count >= 7) {
          clearInterval(interval);
          diceWrapper.classList.remove("animate");
          setDiceFace(finalValue);
          callback();
        }
      }, 80);
    }

    /* ===== 9. WINNER OVERLAY ===== */

    function showWinner(name) {
      winnerText.textContent = `${name} WINS! ðŸŽ‰`;
      winnerOverlay.classList.remove("hidden");
    }

    winnerOverlay.addEventListener("click", () => {
      winnerOverlay.classList.add("hidden");
    });

    // Reset confirmation overlay elements
    const resetOverlay = document.getElementById("resetOverlay");
    const confirmResetBtn = document.getElementById("confirmReset");
    const cancelResetBtn = document.getElementById("cancelReset");

    function doReset() {
      players.forEach(p => p.pos = 1);
      currentPlayerIndex = 0;
      gameOver = false;
      isAnimating = false;
      activeAnimPlayer = null;
      activeAnimType = null;
      setDiceFace(1);
      messageEl.textContent = "";
      rollBtn.disabled = players.length === 0;
      winnerOverlay.classList.add("hidden");
      resetOverlay.classList.add("hidden");
      // Re-enable changing number of players after reset
      playerCountSel.disabled = false;
      updateBoardTokens();
      updateTurnText();
    }

    confirmResetBtn.addEventListener('click', () => {
      doReset();
    });

    cancelResetBtn.addEventListener('click', () => {
      resetOverlay.classList.add('hidden');
    });

    /* ===== 10. MOVE ANIMATION ===== */

    // Helper function to get cell coordinates for smooth positioning
    function getCellCoords(n) {
      const rowFromBottom = Math.floor((n - 1) / 10);
      const colInRow = (n - 1) % 10;
      const isReverse = rowFromBottom % 2 === 1;
      const col = isReverse ? 9 - colInRow : colInRow;
      const gridRow = 10 - rowFromBottom;
      const gridCol = col + 1;
      
      // Return pixel coordinates relative to board
      return {
        x: (gridCol - 1) * 50 + 25, // center of cell
        y: (10 - gridRow) * 50 + 25
      };
    }

    
    
    // Animate a floating token across the board (pixel-based) and place it in the destination cell.
    function animateFloatingToken(player, fromCell, toCell, duration, animClass) {
      return new Promise((resolve) => {
        const boardRect = boardElement.getBoundingClientRect();

        const from = getCellCoords(fromCell);
        const to = getCellCoords(toCell);

        // Create floating token
        const floatDot = document.createElement('div');
        floatDot.className = 'dot ' + player.color + (animClass ? ' ' + animClass : '');
        floatDot.style.position = 'fixed';
        floatDot.style.left = (boardRect.left + from.x - 9) + 'px';
        floatDot.style.top = (boardRect.top + from.y - 9) + 'px';
        floatDot.style.transition = `transform ${duration}ms cubic-bezier(.22,.9,.35,1)`;
        floatDot.style.transform = 'translateZ(0)';
        document.body.appendChild(floatDot);

        // Force reflow then animate using transform to target
        requestAnimationFrame(() => {
          const targetX = boardRect.left + to.x - 9;
          const targetY = boardRect.top + to.y - 9;
          const dx = targetX - (boardRect.left + from.x - 9);
          const dy = targetY - (boardRect.top + from.y - 9);
          floatDot.style.transform = `translate(${dx}px, ${dy}px)`;
        });

        // Cleanup after duration
        setTimeout(() => {
          floatDot.remove();
          resolve();
        }, duration + 20);
      });
    }

    async function movePlayerAnimated(player, diceValue) {
      const start = player.pos;
      let target = start + diceValue;

      if (target > 100) {
        messageEl.textContent = `${player.name} rolled too high and stays on ${player.pos}.`;
        isAnimating = false;
        nextTurn();
        return;
      }

      let viaType = null;
      let finalPos = target;

      if (ladders[target]) {
        viaType = "ladder";
        finalPos = ladders[target];
      } else if (snakes[target]) {
        viaType = "snake";
        finalPos = snakes[target];
      }

      // Phase 1: animate from start cell to target cell (dice roll)
      const diceRollDuration = Math.max(200, diceValue * 180); // ms
      await animateFloatingToken(player, Math.round(start), target, diceRollDuration, null);

      // Place player at target for a moment
      player.pos = target;
      updateBoardTokens();

      // Phase 2: ladder or snake animation uses animClass for visual effect
      if (viaType) {
        activeAnimPlayer = player;
        activeAnimType = viaType;
        updateBoardTokens();

        const ladderDuration = Math.max(300, Math.abs(finalPos - target) * 160);
        await animateFloatingToken(player, target, finalPos, ladderDuration, viaType === 'ladder' ? 'climb' : 'slide');

        activeAnimPlayer = null;
        activeAnimType = null;

        player.pos = finalPos;
        updateBoardTokens();
      }

      let msg = `${player.name} moved to ${target}. `;
      if (viaType === "ladder") msg += `ðŸªœ Climbed to ${finalPos}.`;
      else if (viaType === "snake") msg += `ðŸ Slid to ${finalPos}.`;

      if (finalPos === 100) {
        messageEl.textContent = `ðŸ† ${player.name} wins!`;
        gameOver = true;
        rollBtn.disabled = true;
        isAnimating = false;
        showWinner(player.name);
        return;
      }

      messageEl.textContent = msg;
      isAnimating = false;
      nextTurn();
    }

    /* ===== 11. ROLL BUTTON ===== */

    rollBtn.onclick = function () {
      if (gameOver || isAnimating || !players.length) return;
      const player = players[currentPlayerIndex];
      const dice = Math.floor(Math.random() * 6) + 1;

      isAnimating = true;
      animateDice(dice, () => movePlayerAnimated(player, dice));
    };

    function nextTurn() {
      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      updateTurnText();
    }

    /* ===== 12. RESET ===== */

    resetBtn.onclick = function () {
      // Show confirmation overlay before resetting
      resetOverlay.classList.remove('hidden');
    };
  </script>
</body>
</html>
